---
title: 20190527记录
date: 2019-08-16 13:21:54
tags:
---

# 0527

---

编辑器列表上下键切换选中对象

对选中的模型描边处理

---

## WT

```lua
for k, v in ipairs(variableUI.meshList:getSelectNodes()) do
	table.insert(variable.chooseMeshes, v.mesh)
end
```

记录的是选中的mesh

1. 在drawMesh前判断该mesh是否在表中

   `renderSceneNode`事件中

```lua
local draw = false
for i, m in ipairs(variable.chooseMeshes) do
    if m == mesh then
        local eg = _rd.edge
        local egcolor = _rd.edgeColor
        _rd.edge = true
        _rd.edgeColor = _Color.Green
        mesh:drawMesh()
        draw = true
        _rd.edge = eg
        _rd.edgeColor = egcolor
    end
end
-- 如果没找到，直接drawMesh
if not draw then
    mesh:drawMesh()
end
```

2. 给mesh添加新的属性

选中状态的mesh加ischoosed属性，drawMesh直接判断该属性是否为真

非选中状态置为false：在`updateSelectedUI`中先将该属性全置为false

3. **mesh有select属性**

直接判断selected，OK， 第三种方法



**动态**

Q：摄像机距离look点 or **距离模型的距离**

根据摄像机距离远近计算描边值的大小

一段距离范围内是描边1，不变

中间线性变化

到超出某个距离，描边5，不变

```lua
	if mesh.selected then
		local eg = _rd.edge
		local egcolor = _rd.edgeColor
		local egquality = _rd.edgeQuality
		local pos = tmpVar.vec3_1
		mesh.node.transform:getTranslation(pos)
		local dis = _Vector3.distance(pos, _rd.camera.eye)

		_rd.edge = true
		_rd.edgeColor = _Color.Green
		_rd.edgeQuality = dis < 200 and 1 or (dis > 900 and 5 or 1 + (dis - 200) / 175)
		mesh:drawMesh()
		_rd.edge = eg
		_rd.edgeColor = egcolor
		_rd.edgeQuality = egquality
	else
		mesh:drawMesh()
	end
```





## ListNode-mapOne

### ui

```lua
mylist = list^{
	-- w, h, ...
    node = listnode^{
        -- etc
    }
}
```

### mapOne

```lua
-- TRegister.init
ut.LISTNODE = function(u, key, fget, fset)
    assert(u.node)

    u.node.click = function(self)
        verbose('[Reg][nodeclick]')
        fset()
    end
end
```





## 自动测试

1. 固定时间停止，是否有最长时间限制
2. 33帧截图截了30帧



待解决，是在之前每帧截图，还是之后截图

doStep是在每一帧回调函数运行前，前两帧跳过，第三帧截图false，到第四帧前开始截图；

Q：

1. 每帧渲染，那么每次渲染出的图像会持续多久

   （1）一帧是一个张图，那么截图在drawMesh之前，截到的是什么时候的图像

   （2）那么一张图是持续一段时间吗，固定时间 or 帧间隔

2. 在FobCreate之后，马上进入onIdle循环，前两帧黑屏发生在什么时候

   每一步在做回调函数，那么是在第三帧开始才有图像？前两帧的回调函数是否执行了？

   打印例子每一帧的行为，第一个pfx在onIdle前三帧tickcount有计数，但是在自动测试里两帧是跳过不截图的，那么第一个特效的截图为什么相比较第二个第三个特效一样多，而不是少？

3. 根据例子的打印，33帧截图截了30帧，最后四次drawMesh截到两张图

4. `---4,29
   drawMesh
   change msh
   ---5,30
   drawMesh
   CaptureScreen,5,1`

   29帧在渲染上一个模型，然后换了一个模型，在30帧渲染换了的模型，30帧之前的截图是谁

   



step：

[0]skip

[0]skip（前两帧的回调函数是否执行了）

[1]false不截图

[2]截图 capture1

[36]

# 0528

观察截图：渲染效果滞后于代码 

自动测试遗留问题：

1. 画面比代码延迟两帧，OpenGL前两帧黑屏。截图的画面与代码渲染的内容是什么关系？
2. 每渲染一帧，图像停留多久？自动测试每帧的工作是先截图后渲染，所以在这一帧还能看到上一帧的图像？
3. pfx最后一帧是黑屏的原因

如果说当前帧drawMesh，下一帧执行函数前截图截到的在当前帧渲染的结果：

- 截图内容相对于代码中的渲染信息滞后一帧

- 特效的黑图发生在stopAll和play之后的一帧（猜测stopAll是在当前帧马上停止播放特效，当前帧代码中的play在下一帧开始播放）

帧间隔由什么确定：

执行代码的时间和渲染的时间确定。代码复杂度越高，渲染内容越多，帧数变小，帧间隔变大。

处理：现在在最后多跑两帧补上了最后缺的截图，黑屏的帧不截图，截图名称中带了资源名字

每一帧的代码部分与渲染和帧间隔的关系

**如果没有某类资源？该如何处理**



截图测试：

```lua
local mesh = _Mesh.new('skybox_001.msh')
local pp = _ParticlePlayer.new()
pp:play('env_char_yinji_02_ui.pfx')
local c = 0

_app:onIdle(function()
	c = c + 1
	_rd:captureScreen('capture0\\capture' .. c .. '.bmp')
	mesh:drawMesh()
	if c > 10 then _abort() end
	_rd:captureScreen('capture1\\capture' .. c .. '.bmp')
end)
```

两个截图数目**相同**，截图的结果也完全相同（**_abort()**的效果）

现在的是frontBuffer和backBuffer

每一帧先计算到backBuffer，每帧交换一次，backBuffer变成frontBuffer，frontBuffer变成backBuffer

**GPU、显卡**

每一帧当中：

1. 执行函数
2. 渲染
3. （渲染末端）屏幕刷新SwapBuffers
4. vertical syncronisation

程序每一帧的函数全部执行完之后，还要等屏幕刷新了才去执行下一帧

每一帧渲染完后来到SwapBuffers，都要悲情地等待下一次屏幕刷新的时刻到来，再交换前后缓冲并开始执行下一帧

play pfx放到onIdle之前或者放到onIdle第一帧，截图结果相同

OpenGl的颜色缓冲区，前缓冲区和后缓冲区（可以指定）





提交：

1. oepration.lua
2. checkresource.lua
3. replayone



只跑资源检查

那么

出错后自动停止



1. 资源加载出错的原因
2. 资源数目过多，内存问题
3. watcher







抽象自动测试内容：
autoreplay.lua



# 0529

测试第一版提交

问题：只能截图一部分

原因：自动测试的入口设置了时间监控，限制运行时间



自动测试抽象

将基本功能模块化

（分析如何抽象功能：1. 分析每个模块的输入和输出；2. dofile加入功能模块；3. 分为模块化（面向对象）的内容和具体实现（面向过程）的部分）



晚上添加草的高光贴图模块

# 0530

早上测试高光贴图问题

请侯哥看问题，UI做调整，中英文，最大最小值范围

调整选中模型的描边尺寸，去掉了上限5，目前可达的范围1~50左右

自动测试的实现方式调整

# 0531

自动测试调整结构

尽量用方法去访问，不要直接访问模块中的属性

**过程**：

1. All中给出例子脚本和操作步骤脚本的路径
2. 生成命令执行One

>宣讲会时胡总监推荐过《代码大全》，买完书大概翻过，与代码本身相关的内容并不多，基本从思想和好的习惯以及软件架构系统等方面讲的。
>
>翻完没什么映像，大体就是哦纯粹写代码之外内容很多，但是我都没什么具体的感受，也没记住什么
>
>入职到现在，学到了许多，再回想一些看到的句子以及入职之初柳哥讲的话，慢慢有了具体的认识。总体来讲，开始有些自以为是，看到的信息也有些太过想当然了
>
>比如“逻辑思考”，“从人类最基本的需求出发”，“先明白需求是什么，分析需求”
>
>抽象的能力，将功能模块化。第一次感叹是看到草的新结构，佩服能做出这样的抽象，输入是函数、UI、UI 类型，输出是函数。第一次在实际中看到将“函数指针”类似的运用，将它作为抽象模块的输入和输出。
>
>对，还有思考问题的方式。慢慢看到自己的限制，正在学用不同的方式去思考问题。比如自动测试的抽象过程，“这个文件的输入和输出是什么”。输入和输出，抽象问题的两个重要信息。
>
>准确来讲，我之前用过的抽象是抽象一个新的数据类型，而现在看到具体是怎样抽象一个功能模块，而不仅仅是新的数据类型。





















# 0601

截图的序号（帧号）

截图名字（capturename，用方法设置？）



步骤传入方法（oplua/steps）



两者间写命令的方式区别：

cmd命令行

_sys:command

（配置文件）



如果没有特效，或者只开始渲染别的资源

tickcount的初值，如果pfx == -1，  -1+ 3 = 2，NO



直接截图截不到，不在视线范围内

摄像机位置默认（100,100,100）

根据包围盒大小适当缩放摄像机位置



加载场景引擎崩溃

场景的摄像机位置切换

场景至少2帧，有特效的话第一帧截不到



加载场景需要把路径定位到







